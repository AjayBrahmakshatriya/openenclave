// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "switchless_u.h"
#include <openenclave/edger8r/host.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#if (__SWITCHLESS__)
#include "pal_atomic_uint32.h"
#endif // __SWITCHLESS__

OE_EXTERNC_BEGIN

#if (__SWITCHLESS__)
/* Switchless infrastructure methods */

oe_result_t switchless_enc_worker_thread(
    oe_enclave_t* enclave,
    thread_control* ptc)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */
    switchless_enc_worker_thread_args_t _args, *_pargs_in = NULL,
                                               *_pargs_out = NULL;

    /* Marshaling buffer and sizes */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.ptc = ptc;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(
        _input_buffer_size, sizeof(switchless_enc_worker_thread_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(
        _output_buffer_size, sizeof(switchless_enc_worker_thread_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*)malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function */
    _result = oe_call_enclave_function(
        enclave,
        fcn_id_switchless_enc_worker_thread,
        _input_buffer,
        _input_buffer_size,
        _output_buffer,
        _output_buffer_size,
        &_output_bytes_written);
    if (OE_OK != _result)
    {
        goto done;
    }

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    _result = _pargs_out->_result;

    /* Check if the call succeeded */
    if (OE_OK != _result)
    {
        goto done;
    }

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }

done:
    if (_buffer)
    {
        free(_buffer);
    }
    return _result;
}
#endif // __SWITCHLESS__

/* Wrappers for standard ecalls */

// the standard oeedger8r generated version
oe_result_t standard_enc_sum(
    oe_enclave_t* enclave,
    int* _retval,
    int arg1,
    int arg2)
{
    // printf("  <standard_enc_sum>\n");
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */
    standard_enc_sum_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshaling buffer and sizes */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.arg1 = arg1;
    _args.arg2 = arg2;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(standard_enc_sum_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(standard_enc_sum_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*)malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function */
    _result = oe_call_enclave_function(
        enclave,
        fcn_id_standard_enc_sum,
        _input_buffer,
        _input_buffer_size,
        _output_buffer,
        _output_buffer_size,
        &_output_bytes_written);
    if (OE_OK != _result)
    {
        // printf("    FAILED (0): %s\n", oe_result_str(_result));
        goto done;
    }

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    _result = _pargs_out->_result;

    /* Check if the call succeeded */
    if (OE_OK != _result)
    {
        goto done;
    }

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

done:
    if (_buffer)
    {
        free(_buffer);
    }
    // printf("  </standard_enc_sum>\n");
    return _result;
}

/* Wrappers for synchronous switchless ecalls */

oe_result_t synchronous_switchless_enc_sum(
#if (__SWITCHLESS__)
    thread_control* p_thread_control,
#else  // __SWITCHLESS__
    oe_enclave_t* enclave,
#endif // __SWITCHLESS__
    int* _retval,
    int arg1,
    int arg2)
{
    // printf("  <synchronous_switchless_enc_sum\n");
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */
    synchronous_switchless_enc_sum_args_t _args, *_pargs_in = NULL,
                                                 *_pargs_out = NULL;

    /* Marshaling buffer and sizes */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
#if (__SWITCHLESS__)
    size_t _total_buffer_size = sizeof(tc_queue_node);
#else  // __SWITCHLESS__
    size_t _total_buffer_size = 0;
#endif // __SWITCHLESS__
    uint8_t* _buffer = NULL;
#if (__SWITCHLESS__)
    tc_queue_node* _queue_node = NULL;
#endif // __SWITCHLESS__
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
#if !(__SWITCHLESS__)
    size_t _output_bytes_written = 0;
#endif // !__SWITCHLESS__

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.arg1 = arg1;
    _args.arg2 = arg2;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(
        _input_buffer_size, sizeof(synchronous_switchless_enc_sum_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(
        _output_buffer_size, sizeof(synchronous_switchless_enc_sum_args_t));

    /* Allocate marshaling buffer */
#if (__SWITCHLESS__)
    OE_ADD_SIZE(_total_buffer_size, _input_buffer_size);
#else  // __SWITCHLESS__
    _total_buffer_size = _input_buffer_size;
#endif // __SWITCHLESS__
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*)malloc(_total_buffer_size);
#if (__SWITCHLESS__)
    _queue_node = (tc_queue_node*)_buffer;
    _input_buffer = _buffer + sizeof(tc_queue_node);
    _output_buffer = _buffer + sizeof(tc_queue_node) + _input_buffer_size;
#else  // __SWITCHLESS__
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
#endif // __SWITCHLESS__
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

#if (__SWITCHLESS__)
    /* complete the queue_node */
    init_lockless_queue_node(&(_queue_node->_node));
    _queue_node->type = ET_SYNCHRONOUS;
    atomic_uint32_store(&(_queue_node->data.sync.lock), 0);
    _queue_node->function_id = fcn_id_synchronous_switchless_enc_sum;
    _queue_node->input_buffer = _input_buffer;
    _queue_node->input_buffer_size = _input_buffer_size;
    _queue_node->output_buffer = _output_buffer;
    _queue_node->output_buffer_size = _output_buffer_size;
    _queue_node->output_bytes_written = 0;

    // enqueue the node
    tc_push_enc_queue(p_thread_control, _queue_node);

    /* spin while we wait for completion */
    while (1 != atomic_uint32_load(&(_queue_node->data.sync.lock)))
    {
        continue;
    }
#else  // __SWITCHLESS__
    /* Call enclave function */
    if ((_result = oe_call_enclave_function(
             enclave,
             fcn_id_synchronous_switchless_enc_sum,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
    {
        goto done;
    }
#endif // __SWITCHLESS__

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    _result = _pargs_out->_result;

    /* Check if the call succeeded */
    if (OE_OK != _result)
    {
        goto done;
    }

#if (__SWITCHLESS__)
    if (_queue_node->output_bytes_written != _queue_node->output_buffer_size)
    {
        // printf(
        //     "    _queue_node->output_bytes_written != "
        //     "_queue_node->output_buffer_size\n");
        // printf("    _queue_node->output_bytes_written: %lu\n",
        //     _queue_node->output_bytes_written);
        // printf("    _queue_node->output_buffer_size: %lu\n",
        //     _queue_node->output_buffer_size);
        _result = OE_FAILURE;
        goto done;
    }
#else // __SWITCHLESS__
    if (_output_bytes_written != _output_buffer_size)
    {
        goto done;
    }
#endif

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

done:
    if (_buffer)
    {
        free(_buffer);
    }
    // printf("  </synchronous_switchless_enc_sum>\n");
    return _result;
}

/* ocall functions */

/* ocall function table */
static oe_ocall_func_t __switchless_ocall_function_table[] = {NULL};

oe_result_t oe_create_switchless_enclave(
    const char* path,
    oe_enclave_type_t type,
    uint32_t flags,
    const void* config,
    uint32_t config_size,
    oe_enclave_t** enclave)
{
    return oe_create_enclave(
        path,
        type,
        flags,
        config,
        config_size,
        __switchless_ocall_function_table, // ocall_table
        0,                                 // ocall_table_size
        enclave);
}

OE_EXTERNC_END
